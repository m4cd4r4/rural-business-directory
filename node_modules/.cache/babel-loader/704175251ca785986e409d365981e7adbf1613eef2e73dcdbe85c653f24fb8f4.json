{"ast":null,"code":"/**\n * API Service Layer for Rural Business Directory\n * Handles all API communication with the backend\n */\n\n// localStorage keys (must match AdminPage.js)\nconst ADMIN_DATA_KEY = 'importedBusinessesData';\nconst INDUSTRIES_METADATA_KEY = 'importedIndustriesMetadata';\nconst STATES_METADATA_KEY = 'importedStatesMetadata';\nconst REGIONS_METADATA_KEY = 'importedRegionsMetadata';\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\n\n/**\n * Generic API request handler with error handling\n */\nconst apiRequest = async (endpoint, options = {}) => {\n  const url = `${API_BASE_URL}${endpoint}`;\n  const config = {\n    headers: {\n      'Content-Type': 'application/json',\n      ...options.headers\n    },\n    ...options\n  };\n  try {\n    const response = await fetch(url, config);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error(`API request failed for ${endpoint}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Business API endpoints\n */\nexport const businessAPI = {\n  // Get all businesses with optional filters\n  getBusinesses: async (filters = {}) => {\n    try {\n      const localDataString = localStorage.getItem(ADMIN_DATA_KEY);\n      if (localDataString) {\n        console.log('api.js: Found businesses in localStorage');\n        let allBusinesses = JSON.parse(localDataString);\n        let filteredBusinesses = [...allBusinesses];\n\n        // Apply search filter (case-insensitive on multiple fields)\n        if (filters.search) {\n          const searchTerm = filters.search.toLowerCase();\n          filteredBusinesses = filteredBusinesses.filter(b => {\n            var _b$name, _b$tagline, _b$description, _b$location, _b$location$town, _b$categories, _b$categories$primary, _b$categories2, _b$tags, _b$tags2;\n            return ((_b$name = b.name) === null || _b$name === void 0 ? void 0 : _b$name.toLowerCase().includes(searchTerm)) || ((_b$tagline = b.tagline) === null || _b$tagline === void 0 ? void 0 : _b$tagline.toLowerCase().includes(searchTerm)) || ((_b$description = b.description) === null || _b$description === void 0 ? void 0 : _b$description.toLowerCase().includes(searchTerm)) || ((_b$location = b.location) === null || _b$location === void 0 ? void 0 : (_b$location$town = _b$location.town) === null || _b$location$town === void 0 ? void 0 : _b$location$town.toLowerCase().includes(searchTerm)) || ((_b$categories = b.categories) === null || _b$categories === void 0 ? void 0 : (_b$categories$primary = _b$categories.primary) === null || _b$categories$primary === void 0 ? void 0 : _b$categories$primary.toLowerCase().includes(searchTerm)) || ((_b$categories2 = b.categories) === null || _b$categories2 === void 0 ? void 0 : _b$categories2.secondary) && b.categories.secondary.some(s => s.toLowerCase().includes(searchTerm)) || ((_b$tags = b.tags) === null || _b$tags === void 0 ? void 0 : _b$tags.services) && b.tags.services.some(s => s.toLowerCase().includes(searchTerm)) || ((_b$tags2 = b.tags) === null || _b$tags2 === void 0 ? void 0 : _b$tags2.location) && b.tags.location.some(s => s.toLowerCase().includes(searchTerm));\n          });\n        }\n\n        // Apply state filter (can be comma-separated string or array)\n        if (filters.state) {\n          const selectedStates = Array.isArray(filters.state) ? filters.state : filters.state.split(',');\n          if (selectedStates.length > 0) {\n            filteredBusinesses = filteredBusinesses.filter(b => {\n              var _b$location2;\n              return ((_b$location2 = b.location) === null || _b$location2 === void 0 ? void 0 : _b$location2.state) && selectedStates.includes(b.location.state);\n            });\n          }\n        }\n\n        // Apply industry filter (can be comma-separated string or array)\n        if (filters.industry) {\n          const selectedIndustries = Array.isArray(filters.industry) ? filters.industry : filters.industry.split(',');\n          if (selectedIndustries.length > 0) {\n            filteredBusinesses = filteredBusinesses.filter(b => b.industry && selectedIndustries.includes(b.industry));\n          }\n        }\n\n        // Apply region filter (can be comma-separated string or array)\n        if (filters.region) {\n          const selectedRegions = Array.isArray(filters.region) ? filters.region : filters.region.split(',');\n          if (selectedRegions.length > 0) {\n            filteredBusinesses = filteredBusinesses.filter(b => {\n              var _b$location3;\n              return ((_b$location3 = b.location) === null || _b$location3 === void 0 ? void 0 : _b$location3.region) && selectedRegions.includes(b.location.region);\n            });\n          }\n        }\n\n        // Apply sorting\n        if (filters.sortBy) {\n          filteredBusinesses.sort((a, b) => {\n            var _a$location, _b$location4;\n            const valA = String(a[filters.sortBy] || ((_a$location = a.location) === null || _a$location === void 0 ? void 0 : _a$location[filters.sortBy]) || '').toLowerCase();\n            const valB = String(b[filters.sortBy] || ((_b$location4 = b.location) === null || _b$location4 === void 0 ? void 0 : _b$location4[filters.sortBy]) || '').toLowerCase();\n            if (valA < valB) return -1;\n            if (valA > valB) return 1;\n            return 0;\n          });\n        }\n        const totalFilteredCount = filteredBusinesses.length;\n        const limit = parseInt(filters.limit, 10) || 10; // Default limit\n        const offset = parseInt(filters.offset, 10) || 0; // Default offset\n\n        const paginatedBusinesses = filteredBusinesses.slice(offset, offset + limit);\n        return Promise.resolve({\n          businesses: paginatedBusinesses,\n          pagination: {\n            totalItems: totalFilteredCount,\n            totalPages: Math.ceil(totalFilteredCount / limit),\n            currentPage: Math.floor(offset / limit) + 1,\n            itemsPerPage: limit\n          }\n        });\n      }\n    } catch (e) {\n      console.error('Error reading/processing businesses from localStorage:', e);\n      // Fall through to API request if localStorage fails\n    }\n\n    // Fallback to API if no local data or error\n    console.log('api.js: No businesses in localStorage or error, trying API fallback for getBusinesses');\n    const queryParams = new URLSearchParams();\n    if (filters.search) queryParams.append('search', filters.search);\n    if (filters.state) queryParams.append('state', filters.state); // Assuming API takes comma-separated\n    if (filters.industry) queryParams.append('industry', filters.industry); // Assuming API takes comma-separated\n    if (filters.region) queryParams.append('region', filters.region); // Assuming API takes comma-separated\n    if (filters.limit) queryParams.append('limit', filters.limit);\n    if (filters.offset) queryParams.append('offset', filters.offset);\n    if (filters.sortBy) queryParams.append('sortBy', filters.sortBy);\n    const endpoint = `/businesses${queryParams.toString() ? `?${queryParams}` : ''}`;\n    return apiRequest(endpoint);\n  },\n  // Get single business by ID\n  getBusinessById: async id => {\n    try {\n      const localDataString = localStorage.getItem(ADMIN_DATA_KEY);\n      if (localDataString) {\n        console.log('api.js: Found businesses in localStorage for getBusinessById');\n        const allBusinesses = JSON.parse(localDataString);\n        // Ensure ID comparison is consistent (e.g., string to string or number to number)\n        // Business IDs from fileImport.js are numbers (row numbers). useParams gives string.\n        const numericId = parseInt(id, 10);\n        const business = allBusinesses.find(b => b.id === numericId);\n        if (business) {\n          return Promise.resolve(business); // API often wraps in { business: ... } or { data: ... }\n          // useBusinessProfile expects the business object directly.\n        }\n        // If not found in local, could fall through or return specific not found\n      }\n    } catch (e) {\n      console.error('Error reading/processing business by ID from localStorage:', e);\n    }\n    console.log(`api.js: Business ID ${id} not in localStorage or error, trying API fallback for getBusinessById`);\n    return apiRequest(`/businesses/${id}`);\n  },\n  // Get featured businesses\n  getFeaturedBusinesses: async (limit = 5) => {\n    try {\n      const localDataString = localStorage.getItem(ADMIN_DATA_KEY);\n      if (localDataString) {\n        console.log('api.js: Found businesses in localStorage for getFeaturedBusinesses');\n        const allBusinesses = JSON.parse(localDataString);\n        const featured = allBusinesses.filter(b => b.featured === true);\n        // If not enough featured, can supplement or just return what's available\n        const result = featured.length > 0 ? featured.slice(0, limit) : allBusinesses.slice(0, limit); // Fallback to any if no \"featured\"\n        return Promise.resolve(result); // Assuming direct array is expected\n      }\n    } catch (e) {\n      console.error('Error reading/processing featured businesses from localStorage:', e);\n    }\n    console.log('api.js: No featured businesses in localStorage or error, trying API fallback for getFeaturedBusinesses');\n    return apiRequest(`/businesses/featured?limit=${limit}`);\n  },\n  // Search businesses\n  searchBusinesses: async (searchTerm, filters = {}) => {\n    const queryParams = new URLSearchParams({\n      q: searchTerm,\n      ...filters\n    });\n    return apiRequest(`/businesses/search?${queryParams}`);\n  },\n  // Submit new business (if submission feature is enabled)\n  submitBusiness: async businessData => {\n    return apiRequest('/businesses', {\n      method: 'POST',\n      body: JSON.stringify(businessData)\n    });\n  },\n  // Update business (for business owners)\n  updateBusiness: async (id, businessData) => {\n    return apiRequest(`/businesses/${id}`, {\n      method: 'PUT',\n      body: JSON.stringify(businessData)\n    });\n  }\n};\n\n/**\n * Category and metadata API endpoints\n */\nexport const metadataAPI = {\n  // Get all industry categories\n  getIndustries: async () => {\n    try {\n      const localDataString = localStorage.getItem(INDUSTRIES_METADATA_KEY);\n      if (localDataString) {\n        console.log('api.js: Found industries in localStorage');\n        return Promise.resolve(JSON.parse(localDataString));\n      }\n    } catch (e) {\n      console.error('Error reading industries from localStorage:', e);\n    }\n    console.log('api.js: No industries in localStorage or error, trying API fallback for getIndustries');\n    return apiRequest('/metadata/industries');\n  },\n  // Get all states/territories\n  getStates: async () => {\n    try {\n      const localDataString = localStorage.getItem(STATES_METADATA_KEY);\n      if (localDataString) {\n        console.log('api.js: Found states in localStorage');\n        return Promise.resolve(JSON.parse(localDataString));\n      }\n    } catch (e) {\n      console.error('Error reading states from localStorage:', e);\n    }\n    console.log('api.js: No states in localStorage or error, trying API fallback for getStates');\n    return apiRequest('/metadata/states');\n  },\n  // Get regions by state\n  getRegionsByState: async state => {\n    // This one is harder to serve from combined local data without more complex filtering\n    // For now, it will always hit the API or we'd need to filter REGIONS_METADATA_KEY by state.\n    // Let's assume REGIONS_METADATA_KEY contains all regions and filter it.\n    try {\n      const localDataString = localStorage.getItem(REGIONS_METADATA_KEY);\n      if (localDataString && state) {\n        console.log('api.js: Found regions in localStorage, filtering by state for getRegionsByState');\n        const allRegions = JSON.parse(localDataString);\n        // This assumes regions in localStorage have a 'state' property or similar for filtering\n        // The current AdminPage.js stores regions as {id, name}. We'd need to adjust storage or this logic.\n        // For simplicity, if AdminPage stores regions with state info, this could work.\n        // If not, this specific function might be better off hitting API or returning all regions.\n        // Let's assume for now it returns all regions if state filter isn't easy.\n        // Or, if regions are simple strings/objects without state, this won't filter.\n        // The AdminPage stores regions as {id, name}. No state property.\n        // So, this function will effectively return all regions if local, or hit API.\n        // To make it truly local, AdminPage would need to store regions per state or regions with state property.\n        // For now, let's just return all local regions if any, or hit API.\n        return Promise.resolve(allRegions); // Returns all stored regions\n      }\n    } catch (e) {\n      console.error('Error reading regions from localStorage for getRegionsByState:', e);\n    }\n    console.log('api.js: No regions in localStorage for state or error, trying API fallback for getRegionsByState');\n    return apiRequest(`/metadata/regions?state=${state}`);\n  },\n  // Get all regions\n  getAllRegions: async () => {\n    try {\n      const localDataString = localStorage.getItem(REGIONS_METADATA_KEY);\n      if (localDataString) {\n        console.log('api.js: Found allRegions in localStorage');\n        return Promise.resolve(JSON.parse(localDataString));\n      }\n    } catch (e) {\n      console.error('Error reading allRegions from localStorage:', e);\n    }\n    console.log('api.js: No allRegions in localStorage or error, trying API fallback for getAllRegions');\n    return apiRequest('/metadata/regions');\n  }\n};\n\n/**\n * Statistics API endpoints\n */\nexport const statsAPI = {\n  // Get directory statistics\n  getStats: async () => {\n    return apiRequest('/stats');\n  },\n  // Get popular searches\n  getPopularSearches: async (limit = 10) => {\n    return apiRequest(`/stats/searches?limit=${limit}`);\n  }\n};\n\n/**\n * Error handling utilities\n */\nexport const handleAPIError = error => {\n  if (error.name === 'TypeError' && error.message.includes('fetch')) {\n    return 'Network error. Please check your internet connection.';\n  }\n  if (error.message.includes('404')) {\n    return 'The requested resource was not found.';\n  }\n  if (error.message.includes('500')) {\n    return 'Server error. Please try again later.';\n  }\n  return error.message || 'An unexpected error occurred.';\n};\n\n/**\n * Cache management for better performance\n */\nconst cache = new Map();\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n\nexport const getCachedData = key => {\n  const cached = cache.get(key);\n  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {\n    return cached.data;\n  }\n  return null;\n};\nexport const setCachedData = (key, data) => {\n  cache.set(key, {\n    data,\n    timestamp: Date.now()\n  });\n};\nexport const clearCache = () => {\n  cache.clear();\n};","map":{"version":3,"names":["ADMIN_DATA_KEY","INDUSTRIES_METADATA_KEY","STATES_METADATA_KEY","REGIONS_METADATA_KEY","API_BASE_URL","process","env","REACT_APP_API_URL","apiRequest","endpoint","options","url","config","headers","response","fetch","ok","Error","status","data","json","error","console","businessAPI","getBusinesses","filters","localDataString","localStorage","getItem","log","allBusinesses","JSON","parse","filteredBusinesses","search","searchTerm","toLowerCase","filter","b","_b$name","_b$tagline","_b$description","_b$location","_b$location$town","_b$categories","_b$categories$primary","_b$categories2","_b$tags","_b$tags2","name","includes","tagline","description","location","town","categories","primary","secondary","some","s","tags","services","state","selectedStates","Array","isArray","split","length","_b$location2","industry","selectedIndustries","region","selectedRegions","_b$location3","sortBy","sort","a","_a$location","_b$location4","valA","String","valB","totalFilteredCount","limit","parseInt","offset","paginatedBusinesses","slice","Promise","resolve","businesses","pagination","totalItems","totalPages","Math","ceil","currentPage","floor","itemsPerPage","e","queryParams","URLSearchParams","append","toString","getBusinessById","id","numericId","business","find","getFeaturedBusinesses","featured","result","searchBusinesses","q","submitBusiness","businessData","method","body","stringify","updateBusiness","metadataAPI","getIndustries","getStates","getRegionsByState","allRegions","getAllRegions","statsAPI","getStats","getPopularSearches","handleAPIError","message","cache","Map","CACHE_DURATION","getCachedData","key","cached","get","Date","now","timestamp","setCachedData","set","clearCache","clear"],"sources":["C:/Users/Hard-Worker/Desktop/rural-business-directory/src/services/api.js"],"sourcesContent":["/**\n * API Service Layer for Rural Business Directory\n * Handles all API communication with the backend\n */\n\n// localStorage keys (must match AdminPage.js)\nconst ADMIN_DATA_KEY = 'importedBusinessesData';\nconst INDUSTRIES_METADATA_KEY = 'importedIndustriesMetadata';\nconst STATES_METADATA_KEY = 'importedStatesMetadata';\nconst REGIONS_METADATA_KEY = 'importedRegionsMetadata';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\n\n/**\n * Generic API request handler with error handling\n */\nconst apiRequest = async (endpoint, options = {}) => {\n  const url = `${API_BASE_URL}${endpoint}`;\n  \n  const config = {\n    headers: {\n      'Content-Type': 'application/json',\n      ...options.headers,\n    },\n    ...options,\n  };\n\n  try {\n    const response = await fetch(url, config);\n    \n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error(`API request failed for ${endpoint}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Business API endpoints\n */\nexport const businessAPI = {\n  // Get all businesses with optional filters\n  getBusinesses: async (filters = {}) => {\n    try {\n      const localDataString = localStorage.getItem(ADMIN_DATA_KEY);\n      if (localDataString) {\n        console.log('api.js: Found businesses in localStorage');\n        let allBusinesses = JSON.parse(localDataString);\n        let filteredBusinesses = [...allBusinesses];\n\n        // Apply search filter (case-insensitive on multiple fields)\n        if (filters.search) {\n          const searchTerm = filters.search.toLowerCase();\n          filteredBusinesses = filteredBusinesses.filter(b => \n            b.name?.toLowerCase().includes(searchTerm) ||\n            b.tagline?.toLowerCase().includes(searchTerm) ||\n            b.description?.toLowerCase().includes(searchTerm) ||\n            b.location?.town?.toLowerCase().includes(searchTerm) ||\n            b.categories?.primary?.toLowerCase().includes(searchTerm) ||\n            (b.categories?.secondary && b.categories.secondary.some(s => s.toLowerCase().includes(searchTerm))) ||\n            (b.tags?.services && b.tags.services.some(s => s.toLowerCase().includes(searchTerm))) ||\n            (b.tags?.location && b.tags.location.some(s => s.toLowerCase().includes(searchTerm)))\n          );\n        }\n\n        // Apply state filter (can be comma-separated string or array)\n        if (filters.state) {\n          const selectedStates = Array.isArray(filters.state) ? filters.state : filters.state.split(',');\n          if (selectedStates.length > 0) {\n            filteredBusinesses = filteredBusinesses.filter(b => b.location?.state && selectedStates.includes(b.location.state));\n          }\n        }\n        \n        // Apply industry filter (can be comma-separated string or array)\n        if (filters.industry) {\n          const selectedIndustries = Array.isArray(filters.industry) ? filters.industry : filters.industry.split(',');\n          if (selectedIndustries.length > 0) {\n            filteredBusinesses = filteredBusinesses.filter(b => b.industry && selectedIndustries.includes(b.industry));\n          }\n        }\n\n        // Apply region filter (can be comma-separated string or array)\n        if (filters.region) {\n          const selectedRegions = Array.isArray(filters.region) ? filters.region : filters.region.split(',');\n          if (selectedRegions.length > 0) {\n            filteredBusinesses = filteredBusinesses.filter(b => b.location?.region && selectedRegions.includes(b.location.region));\n          }\n        }\n        \n        // Apply sorting\n        if (filters.sortBy) {\n          filteredBusinesses.sort((a, b) => {\n            const valA = String(a[filters.sortBy] || a.location?.[filters.sortBy] || '').toLowerCase();\n            const valB = String(b[filters.sortBy] || b.location?.[filters.sortBy] || '').toLowerCase();\n            if (valA < valB) return -1;\n            if (valA > valB) return 1;\n            return 0;\n          });\n        }\n\n        const totalFilteredCount = filteredBusinesses.length;\n        const limit = parseInt(filters.limit, 10) || 10; // Default limit\n        const offset = parseInt(filters.offset, 10) || 0; // Default offset\n        \n        const paginatedBusinesses = filteredBusinesses.slice(offset, offset + limit);\n        \n        return Promise.resolve({\n          businesses: paginatedBusinesses,\n          pagination: {\n            totalItems: totalFilteredCount,\n            totalPages: Math.ceil(totalFilteredCount / limit),\n            currentPage: Math.floor(offset / limit) + 1,\n            itemsPerPage: limit,\n          }\n        });\n      }\n    } catch (e) {\n      console.error('Error reading/processing businesses from localStorage:', e);\n      // Fall through to API request if localStorage fails\n    }\n    \n    // Fallback to API if no local data or error\n    console.log('api.js: No businesses in localStorage or error, trying API fallback for getBusinesses');\n    const queryParams = new URLSearchParams();\n    if (filters.search) queryParams.append('search', filters.search);\n    if (filters.state) queryParams.append('state', filters.state); // Assuming API takes comma-separated\n    if (filters.industry) queryParams.append('industry', filters.industry); // Assuming API takes comma-separated\n    if (filters.region) queryParams.append('region', filters.region); // Assuming API takes comma-separated\n    if (filters.limit) queryParams.append('limit', filters.limit);\n    if (filters.offset) queryParams.append('offset', filters.offset);\n    if (filters.sortBy) queryParams.append('sortBy', filters.sortBy);\n    \n    const endpoint = `/businesses${queryParams.toString() ? `?${queryParams}` : ''}`;\n    return apiRequest(endpoint);\n  },\n\n  // Get single business by ID\n  getBusinessById: async (id) => {\n    try {\n      const localDataString = localStorage.getItem(ADMIN_DATA_KEY);\n      if (localDataString) {\n        console.log('api.js: Found businesses in localStorage for getBusinessById');\n        const allBusinesses = JSON.parse(localDataString);\n        // Ensure ID comparison is consistent (e.g., string to string or number to number)\n        // Business IDs from fileImport.js are numbers (row numbers). useParams gives string.\n        const numericId = parseInt(id, 10);\n        const business = allBusinesses.find(b => b.id === numericId);\n        if (business) {\n          return Promise.resolve(business); // API often wraps in { business: ... } or { data: ... }\n                                          // useBusinessProfile expects the business object directly.\n        }\n        // If not found in local, could fall through or return specific not found\n      }\n    } catch (e) {\n      console.error('Error reading/processing business by ID from localStorage:', e);\n    }\n    \n    console.log(`api.js: Business ID ${id} not in localStorage or error, trying API fallback for getBusinessById`);\n    return apiRequest(`/businesses/${id}`);\n  },\n\n  // Get featured businesses\n  getFeaturedBusinesses: async (limit = 5) => {\n    try {\n      const localDataString = localStorage.getItem(ADMIN_DATA_KEY);\n      if (localDataString) {\n        console.log('api.js: Found businesses in localStorage for getFeaturedBusinesses');\n        const allBusinesses = JSON.parse(localDataString);\n        const featured = allBusinesses.filter(b => b.featured === true);\n        // If not enough featured, can supplement or just return what's available\n        const result = featured.length > 0 ? featured.slice(0, limit) : allBusinesses.slice(0, limit); // Fallback to any if no \"featured\"\n        return Promise.resolve(result); // Assuming direct array is expected\n      }\n    } catch (e) {\n      console.error('Error reading/processing featured businesses from localStorage:', e);\n    }\n\n    console.log('api.js: No featured businesses in localStorage or error, trying API fallback for getFeaturedBusinesses');\n    return apiRequest(`/businesses/featured?limit=${limit}`);\n  },\n\n  // Search businesses\n  searchBusinesses: async (searchTerm, filters = {}) => {\n    const queryParams = new URLSearchParams({\n      q: searchTerm,\n      ...filters,\n    });\n    \n    return apiRequest(`/businesses/search?${queryParams}`);\n  },\n\n  // Submit new business (if submission feature is enabled)\n  submitBusiness: async (businessData) => {\n    return apiRequest('/businesses', {\n      method: 'POST',\n      body: JSON.stringify(businessData),\n    });\n  },\n\n  // Update business (for business owners)\n  updateBusiness: async (id, businessData) => {\n    return apiRequest(`/businesses/${id}`, {\n      method: 'PUT',\n      body: JSON.stringify(businessData),\n    });\n  },\n};\n\n/**\n * Category and metadata API endpoints\n */\nexport const metadataAPI = {\n  // Get all industry categories\n  getIndustries: async () => {\n    try {\n      const localDataString = localStorage.getItem(INDUSTRIES_METADATA_KEY);\n      if (localDataString) {\n        console.log('api.js: Found industries in localStorage');\n        return Promise.resolve(JSON.parse(localDataString));\n      }\n    } catch (e) {\n      console.error('Error reading industries from localStorage:', e);\n    }\n    console.log('api.js: No industries in localStorage or error, trying API fallback for getIndustries');\n    return apiRequest('/metadata/industries');\n  },\n\n  // Get all states/territories\n  getStates: async () => {\n    try {\n      const localDataString = localStorage.getItem(STATES_METADATA_KEY);\n      if (localDataString) {\n        console.log('api.js: Found states in localStorage');\n        return Promise.resolve(JSON.parse(localDataString));\n      }\n    } catch (e) {\n      console.error('Error reading states from localStorage:', e);\n    }\n    console.log('api.js: No states in localStorage or error, trying API fallback for getStates');\n    return apiRequest('/metadata/states');\n  },\n\n  // Get regions by state\n  getRegionsByState: async (state) => {\n    // This one is harder to serve from combined local data without more complex filtering\n    // For now, it will always hit the API or we'd need to filter REGIONS_METADATA_KEY by state.\n    // Let's assume REGIONS_METADATA_KEY contains all regions and filter it.\n    try {\n      const localDataString = localStorage.getItem(REGIONS_METADATA_KEY);\n      if (localDataString && state) {\n        console.log('api.js: Found regions in localStorage, filtering by state for getRegionsByState');\n        const allRegions = JSON.parse(localDataString);\n        // This assumes regions in localStorage have a 'state' property or similar for filtering\n        // The current AdminPage.js stores regions as {id, name}. We'd need to adjust storage or this logic.\n        // For simplicity, if AdminPage stores regions with state info, this could work.\n        // If not, this specific function might be better off hitting API or returning all regions.\n        // Let's assume for now it returns all regions if state filter isn't easy.\n        // Or, if regions are simple strings/objects without state, this won't filter.\n        // The AdminPage stores regions as {id, name}. No state property.\n        // So, this function will effectively return all regions if local, or hit API.\n        // To make it truly local, AdminPage would need to store regions per state or regions with state property.\n        // For now, let's just return all local regions if any, or hit API.\n        return Promise.resolve(allRegions); // Returns all stored regions\n      }\n    } catch (e) {\n      console.error('Error reading regions from localStorage for getRegionsByState:', e);\n    }\n    console.log('api.js: No regions in localStorage for state or error, trying API fallback for getRegionsByState');\n    return apiRequest(`/metadata/regions?state=${state}`);\n  },\n\n  // Get all regions\n  getAllRegions: async () => {\n    try {\n      const localDataString = localStorage.getItem(REGIONS_METADATA_KEY);\n      if (localDataString) {\n        console.log('api.js: Found allRegions in localStorage');\n        return Promise.resolve(JSON.parse(localDataString));\n      }\n    } catch (e) {\n      console.error('Error reading allRegions from localStorage:', e);\n    }\n    console.log('api.js: No allRegions in localStorage or error, trying API fallback for getAllRegions');\n    return apiRequest('/metadata/regions');\n  },\n};\n\n/**\n * Statistics API endpoints\n */\nexport const statsAPI = {\n  // Get directory statistics\n  getStats: async () => {\n    return apiRequest('/stats');\n  },\n\n  // Get popular searches\n  getPopularSearches: async (limit = 10) => {\n    return apiRequest(`/stats/searches?limit=${limit}`);\n  },\n};\n\n/**\n * Error handling utilities\n */\nexport const handleAPIError = (error) => {\n  if (error.name === 'TypeError' && error.message.includes('fetch')) {\n    return 'Network error. Please check your internet connection.';\n  }\n  \n  if (error.message.includes('404')) {\n    return 'The requested resource was not found.';\n  }\n  \n  if (error.message.includes('500')) {\n    return 'Server error. Please try again later.';\n  }\n  \n  return error.message || 'An unexpected error occurred.';\n};\n\n/**\n * Cache management for better performance\n */\nconst cache = new Map();\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n\nexport const getCachedData = (key) => {\n  const cached = cache.get(key);\n  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {\n    return cached.data;\n  }\n  return null;\n};\n\nexport const setCachedData = (key, data) => {\n  cache.set(key, {\n    data,\n    timestamp: Date.now(),\n  });\n};\n\nexport const clearCache = () => {\n  cache.clear();\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}